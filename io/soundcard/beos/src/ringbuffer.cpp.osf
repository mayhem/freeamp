// $Id: ringbuffer.cpp.osf,v 1.1 1999/02/10 09:32:24 elrod Exp $

#include "ringbuffer.h"
#include <stdio.h>
#include <assert.h>

#define PRINT(a)		printf a
//#define PRINT(a)
#define RB_PRINT     PRINT
//#define RB_PRINT(a)

void*   REFPTR1;
void*   REFPTR2;

#if 0
#define memcpy_WDEBUG	memcpy
#define memcpy_RDEBUG	memcpy
#else
//#define memcpy_WDEBUG memcpy_DEBUG
//#define memcpy_RDEBUG memcpy_DEBUG
void*   memcpy_RDEBUG( void* dest, const void* src, size_t len )
{
	PRINT(( "%x <= [%x] %d bytes (%x,%x)\n", dest, src, len, REFPTR1, REFPTR2 ));
//	return memcpy( dest, src, len );
	return memcpy( dest, src, 0 );
}
void*   memcpy_WDEBUG( void* dest, const void* src, size_t len )
{
	PRINT(( "[%x] <= %x %d bytes (%x,%x)\n", dest, src, len, REFPTR1, REFPTR2 ));
//	return memcpy( dest, src, len );
	return memcpy( dest, src, 0 );
}
#endif

RingBuffer::RingBuffer( size_t  bufferSize )
:       m_bufferSize( bufferSize ),
	m_buffer( new uint8[ m_bufferSize + 4096 ] ),
	m_readIndex( 0 ),
	m_writeIndex( 0 )
{
	REFPTR1 = m_buffer;
	REFPTR2 = &m_buffer[ bufferSize-1 ];
}

RingBuffer::~RingBuffer()
{
	if ( m_buffer )
	{
		delete[] m_buffer;
		m_buffer = NULL;
	}
}

ssize_t
RingBuffer::Write( const void* data, size_t length )
{
	size_t  bytesToWrite = BufferSize() < length ? BufferSize() : length;
	PRINT(( "RingBuffer::Write:(%d -> %d, %d)\n", m_readIndex, m_writeIndex, m_numBytesInBuffer ));

	assert( length > 0 );

	for ( ;; )
	{
		Lock();
		if ( NumBytesEmpty() < bytesToWrite )
		{
			Unlock();
			m_writerSem.Wait();
		}
		else
		{
			break;
		}
	}
#if 0
	while ( NumBytesEmpty() < bytesToWrite )
	{
		PRINT(( "WriteWait\n" ));
		m_writerSem.Wait();
	}

	Lock();
#endif

#if 0
	if ( m_readIndex == m_writeIndex )
	{
PRINT(( "1\n" ));
		// buffer is empty.
		memcpy_WDEBUG( (m_buffer + m_writeIndex), data, bytesToWrite );
		m_writeIndex += bytesToWrite;
		if ( m_writeIndex == BufferSize() )
		{
			m_writeIndex = 0;
		}
	}
	else if ( m_readIndex < m_writeIndex )
#endif
	if ( m_readIndex <= m_writeIndex )
	{
		if ( bytesToWrite <= (m_bufferSize - m_writeIndex) )
		{
			//
			memcpy_WDEBUG( (m_buffer + m_writeIndex), data, bytesToWrite );
			m_writeIndex += bytesToWrite;
			if ( m_writeIndex == BufferSize() )
			{
				m_writeIndex = 0;
			}
		}
		else
		{
			// data (to be written) strides the tail of the buffer.
			// so i need two memcpy_DEBUG's
PRINT(( "bytesToWrite %d, m_bufferSize %d, writeindx %d\n", bytesToWrite, m_bufferSize, m_writeIndex ));
			size_t  len1 = m_bufferSize - m_writeIndex;
			memcpy_WDEBUG( (m_buffer + m_writeIndex), data, len1 );
			m_writeIndex = 0;
			size_t  len2 = bytesToWrite - len1;
			memcpy_WDEBUG( (m_buffer + m_writeIndex), ((uint8*)data + len1), len2 );
			m_writeIndex += len2;
PRINT(( "len1,2 = %d, %d\n", len1, len2 ));
			assert( m_writeIndex <= m_readIndex );
		}
	}
	else if ( m_readIndex > m_writeIndex )
	{
		memcpy_WDEBUG( (m_buffer + m_writeIndex), data, bytesToWrite );
		m_writeIndex += bytesToWrite;
		assert( m_readIndex >= m_writeIndex );
	}

	m_numBytesInBuffer += bytesToWrite;
	assert( m_writeIndex <= BufferSize() );
	PRINT(( "RingBuffer::Write:(%d -> %d, %d)\n", m_readIndex, m_writeIndex, m_numBytesInBuffer ));

	Unlock();

	m_readerSem.Signal();

	return bytesToWrite;
}

size_t
RingBuffer::Read( void* data, size_t length )
{
	size_t  bytesToRead = BufferSize() < length ? BufferSize() : length;
	RB_PRINT(( "RingBuffer::Read:(%d -> %d, %d)\n", m_readIndex, m_writeIndex, m_numBytesInBuffer ));

//      assert( length > 0 );

//	while ( NumBytesInBuffer() < bytesToRead )
	int	count = 0;
	while ( NumBytesInBuffer() <= 0 )
	{
		RB_PRINT(( "ReadWait\n" ));
		m_readerSem.Wait();
		if ( ++count > 30 )
		{
			return 0;
		}
	}
	if ( bytesToRead > NumBytesInBuffer() )
	{
		bytesToRead = NumBytesInBuffer();
	}
	RB_PRINT(( "Reading %d bytes\n", bytesToRead ));

	Lock();

	if ( m_readIndex < m_writeIndex )
	{
		memcpy_RDEBUG( data, (m_buffer + m_readIndex), bytesToRead );
		m_readIndex += bytesToRead;
		if ( m_readIndex == BufferSize() )
		{
			m_readIndex = 0;
		}
	}
	else if ( m_readIndex >= m_writeIndex )
	{
		if ( bytesToRead <= (m_bufferSize - m_readIndex) )
		{
			memcpy_RDEBUG( data, (m_buffer + m_readIndex), bytesToRead );
			m_readIndex += bytesToRead;
			if ( m_readIndex == BufferSize() )
			{
				m_readIndex = 0;
			}
		}
		else
		{
			// i need two memcpy_DEBUG's
			size_t  len1 = m_bufferSize - m_readIndex;
			memcpy_RDEBUG( data, (m_buffer + m_readIndex), len1 );
			m_readIndex = 0;
			size_t  len2 = bytesToRead - len1;
			memcpy_RDEBUG( ((uint8*)data + len1), (m_buffer + m_readIndex), len2 );
			m_readIndex += len2;
		}
	}

	m_numBytesInBuffer -= bytesToRead;
	RB_PRINT(( "%d bytes has been read\n", bytesToRead ));
	assert( m_readIndex <= BufferSize() );
	RB_PRINT(( "RingBuffer::Read:(%d -> %d, %d)\n", m_readIndex, m_writeIndex, m_numBytesInBuffer ));

	Unlock();

	m_writerSem.Signal();

	return bytesToRead;
}

