#!/usr/bin/perl
#
# gas2intel Copyright (C) 1999 Mark H. Weaver <mhw@netris.org>
#
#   This script converts a subset of AT&T-style x86 assembly, which
#   gas uses, into Intel-style.  It is far from complete, but is just
#   good enough to convert the asm files it is currently needed for.
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
#
# $Id: gas2intel,v 1.4 1999/03/04 01:36:35 mhw Exp $
#

$re_sym = "[A-Za-z_.][A-Za-z0-9_.]*";

sub fatal {
    print STDERR @_;
    exit (1);
}

sub lerr {
    &fatal ("Line $.:", @_);
}

sub translate_sym {
    local $sym = $_[0];

    $sym =~ s/^([A-Za-z_])/_$1/;
    $sym =~ s/^\.//;
    return $sym;
}

sub append_line {
    $repeat_buf .= $leader . $label . $_ . $trailer;
}

%size_prefix = (
    ""  => "",
    "b" => "BYTE PTR ",
    "w" => "WORD PTR ",
    "l" => "DWORD PTR ",
    "q" => "QUAD PTR "		# XXX Just a guess, may be wrong
);

print ";; ***************************************************\n";
print ";; ************ DO NOT EDIT THIS FILE!!!! ************\n";
print ";; ***************************************************\n";
print ";; This file was automatically generated by gas2intel.\n";
print ";; Edit the original gas version instead.\n\n";

$repeat_count = 1;
$repeat_buf = "";

while (<>) {
    chomp;			# Strip trailing newline
    s/\s+$//;			# Strip trailing whitespace

    if (s/(\s*#.*)$//) {	# Move comment to another variable
	$trailer = "$1\n";
	$trailer =~ s/#/;/;	# Change comment prefix
    } else {
	$trailer = "\n";
    }

    if (s/^(\s*)//) {		# Move leading space to another var
	$leader = $1;
    } else {
	$leader = "";
    }

    if (!$header_done && $_ ne "") {
    	$leader = ".386\n" .
		  ";FLAT\tgroup _TEXT\n" .
		  ";\tassume cs:FLAT, ds:FLAT, ss:FLAT\n" .
		  "_TEXT\tsegment para public use32 'CODE'\n\n" .
		  $leader;
    	$header_done = 1;
    }

    if (s/^($re_sym:\s*)//) {	# Move label to another variable
	$label = &translate_sym ($1);
    } else {
	$label = "";
    }

    if ($_ eq "" && $trailer =~ /^\s*;%% (\w+)$/) {
	$_ = $1;
	tr/A-Z/a-z/;
	$trailer = "\n";
	if (/^proc$/) {
	    $proclabel = $label;
	    $label = "";
	    $proclabel =~ s/:.*//;
	    $_ = "$proclabel proc near";
	} elsif (/^endp$/) {
	    $_ = "$proclabel endp";
	    $proclabel = "";
	} else {
	    &lerr ("Unrecognized special comment\n");
	}
    } elsif ($_ eq "") {		# Blank line, no translation
    } elsif (/^\.globa?l\s+($re_sym)$/) {
	my $sym = &translate_sym ($1);

	$_ = "public $sym";
    } elsif (/^\.extern\s+($re_sym)$/) {
	my $sym = &translate_sym ($1);

	$_ = "EXTERN $sym:dword";
    } elsif (/^\.align\s+([0-9]+)$/) {
	$_ = "align $1";	# Don't know how to translate this
    } elsif (/^\.type\s+/) {
	$_ = "";		# No need for .type directives
    } elsif (/^\.size\s+/) {
	$_ = "";		# No need for .size directives
    } elsif (/^\.rept\s+([0-9]+)$/) {
	$_ = "; REPEAT $1";
	&append_line;
	push (@nested_repeat_counts, $repeat_count);
	push (@nested_repeat_bufs, $repeat_buf);
	$repeat_count = $1;
	$repeat_buf = "";
	next;
    } elsif (/^\.endr$/) {
	$repeat_buf .= ";--\n";
	$repeat_buf = pop (@nested_repeat_bufs) .
			($repeat_buf x $repeat_count);
	$repeat_count = pop (@nested_repeat_counts);
	$_ = "; END REPEAT";
    } elsif (/^\./) {
	&fatal ("Unrecognized directive: $_\n");
    } elsif (/^([A-Za-z]+)(\s+(.*))?$/) {
    	$op = $1;
	$_ = $2;
	$_ = "," . $_ if $_ ne "";
	@args = ();

	# XXX: Too simplistic for char consts
	while (s/^\s*,\s*([^,(]*(\([^)]+\))?)\s*//) {
	    push (@args, $1);
	}
	&lerr ("Invalid argument syntax\n") if $_ ne "";

	$_ = $op;
	tr/A-Z/a-z/;	# Convert opcode to all lowercase

	$size = "";
	if (/^(ret|pushad|popad|fld[z1])$/) {
	    # zero-arity instructions
	    &lerr ("Wrong # of args\n") if ($#args != -1);
	    $op = $1;
	} elsif (/^(push|pop|inc|dec|neg|not)([bwlq])$/) {
	    # unary int instructions
	    &lerr ("Wrong # of args\n") if ($#args != 0);
	    $op = $1;
	    $size = $2;
	} elsif (/^(lea|cmp|ad[dc]|s[ub]b|i?mul|i?div|and|or|xor|r[oc][lr]|s[ha][lr]|mov)([bwlq])$/) {
	    # binary int instructions
	    &lerr ("Wrong # of args\n") if ($#args != 1);
	    $op = $1;
	    $size = $2;
	    @args = ($args[1], $args[0]);	# Swap args
	} elsif (/^(test)$/) {
	    # sizeless binary int instructions
	    &lerr ("Wrong # of args\n") if ($#args != 1);
	    $op = $1;
	    @args = ($args[1], $args[0]);	# Swap args
	} elsif (/^(fild|fistp?)([slq])$/) {
	    # unary float-int instructions
	    &lerr ("Wrong # of args\n") if ($#args != 0);
	    $op = $1;
	    $size = $2;
	    $size =~ tr/s/w/;
	} elsif (/^(fld|fstp?)([sl]?)$/) {
	    # unary float instructions
	    &lerr ("Wrong # of args\n") if ($#args != 0);
	    $op = $1;
	    $size = $2;
	    $size =~ tr/sl/lq/;
	} elsif (/^(faddp?|fsubr?p?|fmulp?|fdivr?p?|fxch)([sl]?)$/) {
	    # float instructions with variable arity
	    &lerr ("Wrong # of args\n") if ($#args > 1);
	    $op = $1;
	    $size = $2;
	    $size =~ tr/sl/lq/;
	    if ($#args == 1) {
		@args = ($args[1], $args[0]);	# Swap args if binary
	    }
	} elsif (/^j/) {
	    # jump instructions
	    &lerr ("Wrong # of args\n") if ($#args != 0);
	} else {
	    &lerr ("Unrecognized instruction: $_\n");
	}

	if ($op =~ /^j/) {
	    # jump instructions handled specially
	    $_ = $args[0];
	    if (!s/^\*//) {
		$_ = &translate_sym ($_);
	    }

	    $_ = $op . " " . $_;
	} else {
	    # First scan for int register refs which reveal operand size
	    if (0) {	# Disable this code for now, it's too simplistic
		foreach (@args) {
		    if (/^%/ && !/^%st/) {
			$size = "";
		    }
		}
	    }

	    foreach (@args) {
		if (s/^%//) {				# Register
		} elsif (s/^\$//) {			# Immediate constant
		    $_ = &translate_sym ($_) if /^$re_sym/;
		} elsif (/^(.*)\((.*)\)$/) {	# Memory operand
		    $disp = $1;
		    $elms = $2;
		    if ($disp =~ /^[0-9]/) {
			$symdisp = "";
			$numdisp = "+" . $disp;
		    } elsif ($disp =~ /^[-+]/) {
			$symdisp = "";
			$numdisp = $disp;
		    } else {
			$symdisp = $disp;
			$numdisp = "";
		    }
		    ($base,$index,$scale,$extra) = split (/\s*,\s*/, $elms);
		    $base =~ s/^%//;
		    $index =~ s/^%//;
		    &lerr ("Too many elements in mem ref\n") if ($extra ne "");

		    $_ = $size_prefix{$size} . $symdisp . "[" . $base;
		    $_ .= "+" . $index if $index ne "";
		    $_ .= "*" . $scale if $scale ne "";
		    $_ .= $numdisp . "]";
		}
	    }

	    $_ = $op . " " . join (",", @args);
	}
    } else {
	&lerr ("Unrecognized pattern: $_\n");
    }
    &append_line;
}

if ($#nested_repeat_bufs >= 0) {
    &fatal ("Unterminated .rept directive\n");
}

print $repeat_buf;
print "_TEXT\tends\n";
print "\tend\n";

